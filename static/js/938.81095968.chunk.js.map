{"version":3,"file":"static/js/938.81095968.chunk.js","mappings":"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","sources":["../node_modules/framer-motion/src/utils/use-motion-value-event.ts","../node_modules/motion-dom/dist/es/scroll/observe.mjs","../node_modules/motion-dom/dist/es/resize/handle-element.mjs","../node_modules/motion-dom/dist/es/resize/handle-window.mjs","../node_modules/framer-motion/src/render/dom/scroll/info.ts","../node_modules/framer-motion/src/render/dom/scroll/offsets/edge.ts","../node_modules/framer-motion/src/render/dom/scroll/offsets/offset.ts","../node_modules/framer-motion/src/render/dom/scroll/offsets/presets.ts","../node_modules/framer-motion/src/render/dom/scroll/offsets/index.ts","../node_modules/framer-motion/src/render/dom/scroll/offsets/inset.ts","../node_modules/framer-motion/src/render/dom/scroll/on-scroll-handler.ts","../node_modules/framer-motion/src/render/dom/scroll/track.ts","../node_modules/motion-dom/dist/es/resize/index.mjs","../node_modules/framer-motion/src/render/dom/scroll/utils/get-timeline.ts","../node_modules/framer-motion/src/render/dom/scroll/index.ts","../node_modules/framer-motion/src/render/dom/scroll/attach-function.ts","../node_modules/framer-motion/src/render/dom/scroll/attach-animation.ts","../node_modules/framer-motion/src/value/use-scroll.ts"],"sourcesContent":["\"use client\"\n\nimport { MotionValue, MotionValueEventCallbacks } from \"motion-dom\"\nimport { useInsertionEffect } from \"react\"\n\nexport function useMotionValueEvent<\n    V,\n    EventName extends keyof MotionValueEventCallbacks<V>\n>(\n    value: MotionValue<V>,\n    event: EventName,\n    callback: MotionValueEventCallbacks<V>[EventName]\n) {\n    /**\n     * useInsertionEffect will create subscriptions before any other\n     * effects will run. Effects run upwards through the tree so it\n     * can be that binding a useLayoutEffect higher up the tree can\n     * miss changes from lower down the tree.\n     */\n    useInsertionEffect(\n        () => value.on(event, callback),\n        [value, event, callback]\n    )\n}\n","import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n","import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n","import { progress, velocityPerSecond } from \"motion-utils\"\nimport { AxisScrollInfo, ScrollInfo } from \"./types\"\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50\n\nconst createAxisInfo = (): AxisScrollInfo => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n})\n\nexport const createScrollInfo = (): ScrollInfo => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n})\n\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n} as const\n\nfunction updateAxisInfo(\n    element: Element,\n    axisName: \"x\" | \"y\",\n    info: ScrollInfo,\n    time: number\n) {\n    const axis = info[axisName]\n    const { length, position } = keys[axisName]\n\n    const prev = axis.current\n    const prevTime = info.time\n\n    axis.current = element[`scroll${position}`]\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`]\n\n    axis.offset.length = 0\n    axis.offset[0] = 0\n    axis.offset[1] = axis.scrollLength\n    axis.progress = progress(0, axis.scrollLength, axis.current)\n\n    const elapsed = time - prevTime\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed)\n}\n\nexport function updateScrollInfo(\n    element: Element,\n    info: ScrollInfo,\n    time: number\n) {\n    updateAxisInfo(element, \"x\", info, time)\n    updateAxisInfo(element, \"y\", info, time)\n    info.time = time\n}\n","import { Edge, NamedEdges } from \"../types\"\n\nexport const namedEdges: Record<NamedEdges, number> = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n}\n\nexport function resolveEdge(edge: Edge, length: number, inset = 0) {\n    let delta = 0\n\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge as NamedEdges]\n    }\n\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge)\n\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber\n        } else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100\n        } else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth\n        } else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight\n        } else {\n            edge = asNumber\n        }\n    }\n\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge\n    }\n\n    return inset + delta\n}\n","import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n","import { ProgressIntersection } from \"../types\"\n\nexport const ScrollOffset: Record<string, ProgressIntersection[]> = {\n  Enter: [\n    [0, 1],\n    [1, 1],\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0],\n  ],\n  Any: [\n    [1, 0],\n    [0, 1],\n  ],\n  All: [\n    [0, 0],\n    [1, 1],\n  ],\n}\n","import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n","import { isHTMLElement } from \"motion-dom\"\n\nexport function calcInset(element: Element, container: Element) {\n    const inset = { x: 0, y: 0 }\n\n    let current: Element | null = element\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft\n            inset.y += current.offsetTop\n            current = current.offsetParent\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect()\n            current = current.parentElement!\n            const parentBoundingBox = current.getBoundingClientRect()\n            inset.x += svgBoundingBox.left - parentBoundingBox.left\n            inset.y += svgBoundingBox.top - parentBoundingBox.top\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox()\n            inset.x += x\n            inset.y += y\n\n            let svg: SVGElement | null = null\n            let parent: SVGElement = current.parentNode as SVGElement\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent\n                }\n                parent = current.parentNode as SVGElement\n            }\n            current = svg\n        } else {\n            break\n        }\n    }\n\n    return inset\n}\n","import { warnOnce } from \"motion-utils\"\nimport { updateScrollInfo } from \"./info\"\nimport { resolveOffsets } from \"./offsets/index\"\nimport {\n    OnScrollHandler,\n    OnScrollInfo,\n    ScrollInfo,\n    ScrollInfoOptions,\n} from \"./types\"\n\nfunction measure(\n    container: Element,\n    target: Element = container,\n    info: ScrollInfo\n) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0\n    info.y.targetOffset = 0\n    if (target !== container) {\n        let node = target as HTMLElement\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft\n            info.y.targetOffset += node.offsetTop\n            node = node.offsetParent as HTMLElement\n        }\n    }\n\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight\n    info.x.containerLength = container.clientWidth\n    info.y.containerLength = container.clientHeight\n\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(\n                getComputedStyle(container).position !== \"static\",\n                \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\"\n            )\n        }\n    }\n}\n\nexport function createOnScrollHandler(\n    element: Element,\n    onScroll: OnScrollInfo,\n    info: ScrollInfo,\n    options: ScrollInfoOptions = {}\n): OnScrollHandler {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info)\n            updateScrollInfo(element, info, time)\n\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options)\n            }\n        },\n        notify: () => onScroll(info),\n    }\n}\n","import { cancelFrame, frame, frameData, resize } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { createScrollInfo } from \"./info\"\nimport { createOnScrollHandler } from \"./on-scroll-handler\"\nimport { OnScrollHandler, OnScrollInfo, ScrollInfoOptions } from \"./types\"\n\nconst scrollListeners = new WeakMap<Element, VoidFunction>()\nconst resizeListeners = new WeakMap<Element, VoidFunction>()\nconst onScrollHandlers = new WeakMap<Element, Set<OnScrollHandler>>()\n\nexport type ScrollTargets = Array<HTMLElement>\n\nconst getEventTarget = (element: Element) =>\n    element === document.scrollingElement ? window : element\n\nexport function scrollInfo(\n    onScroll: OnScrollInfo,\n    {\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollInfoOptions = {}\n) {\n    if (!container) return noop as VoidFunction\n\n    let containerHandlers = onScrollHandlers.get(container)\n\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set()\n        onScrollHandlers.set(container, containerHandlers)\n    }\n\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo()\n    const containerHandler = createOnScrollHandler(\n        container,\n        onScroll,\n        info,\n        options\n    )\n    containerHandlers.add(containerHandler)\n\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp)\n            }\n\n            frame.preUpdate(notifyAll)\n        }\n\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify()\n            }\n        }\n\n        const listener = () => frame.read(measureAll)\n\n        scrollListeners.set(container, listener)\n\n        const target = getEventTarget(container)\n        window.addEventListener(\"resize\", listener, { passive: true })\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener))\n        }\n\n        target.addEventListener(\"scroll\", listener, { passive: true })\n\n        listener()\n    }\n\n    const listener = scrollListeners.get(container)!\n    frame.read(listener, false, true)\n\n    return () => {\n        cancelFrame(listener)\n\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container)\n        if (!currentHandlers) return\n\n        currentHandlers.delete(containerHandler)\n\n        if (currentHandlers.size) return\n\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container)\n        scrollListeners.delete(container)\n\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\n                \"scroll\",\n                scrollListener\n            )\n            resizeListeners.get(container)?.()\n            window.removeEventListener(\"resize\", scrollListener)\n        }\n    }\n}\n","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n","import { ProgressTimeline, supportsScrollTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"../track\"\nimport { ScrollOptionsWithDefaults } from \"../types\"\n\ndeclare global {\n    interface Window {\n        ScrollTimeline: ScrollTimeline\n    }\n}\n\ndeclare class ScrollTimeline implements ProgressTimeline {\n    constructor(options: ScrollOptions)\n\n    currentTime: null | { value: number }\n\n    cancel?: VoidFunction\n}\n\nconst timelineCache = new Map<\n    Element,\n    Map<Element | \"self\", { x?: ProgressTimeline; y?: ProgressTimeline }>\n>()\n\nfunction scrollTimelineFallback(options: ScrollOptionsWithDefaults) {\n    const currentTime = { value: 0 }\n\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis!].progress * 100\n    }, options)\n\n    return { currentTime, cancel }\n}\n\nexport function getTimeline({\n    source,\n    container,\n    ...options\n}: ScrollOptionsWithDefaults): ProgressTimeline {\n    const { axis } = options\n\n    if (source) container = source\n\n    const containerCache = timelineCache.get(container) ?? new Map()\n    timelineCache.set(container, containerCache)\n\n    const targetKey = options.target ?? \"self\"\n    const targetCache = containerCache.get(targetKey) ?? {}\n\n    const axisKey = axis + (options.offset ?? []).join(\",\")\n\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis } as any)\n                : scrollTimelineFallback({ container, ...options })\n    }\n\n    return targetCache[axisKey]!\n}\n","import { AnimationPlaybackControls } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { attachToAnimation } from \"./attach-animation\"\nimport { attachToFunction } from \"./attach-function\"\nimport { OnScroll, ScrollOptions } from \"./types\"\n\nexport function scroll(\n    onScroll: OnScroll | AnimationPlaybackControls,\n    {\n        axis = \"y\",\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollOptions = {}\n): VoidFunction {\n    if (!container) return noop as VoidFunction\n\n    const optionsWithDefaults = { axis, container, ...options }\n\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults)\n}\n","import { observeTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"./track\"\nimport { OnScroll, OnScrollWithInfo, ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll: OnScroll): onScroll is OnScrollWithInfo {\n    return onScroll.length === 2\n}\n\nexport function attachToFunction(\n    onScroll: OnScroll,\n    options: ScrollOptionsWithDefaults\n) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis!].progress, info)\n        }, options)\n    } else {\n        return observeTimeline(onScroll, getTimeline(options))\n    }\n}\n","import { AnimationPlaybackControls, observeTimeline } from \"motion-dom\"\nimport { ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\nexport function attachToAnimation(\n    animation: AnimationPlaybackControls,\n    options: ScrollOptionsWithDefaults\n) {\n    const timeline = getTimeline(options)\n\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause()\n\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress\n            }, timeline)\n        },\n    })\n}\n","\"use client\"\n\nimport { motionValue } from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\nimport { RefObject, useCallback, useEffect, useRef } from \"react\"\nimport { scroll } from \"../render/dom/scroll\"\nimport { ScrollInfoOptions } from \"../render/dom/scroll/types\"\nimport { useConstant } from \"../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../utils/use-isomorphic-effect\"\n\nexport interface UseScrollOptions\n    extends Omit<ScrollInfoOptions, \"container\" | \"target\"> {\n    container?: RefObject<HTMLElement | null>\n    target?: RefObject<HTMLElement | null>\n}\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n})\n\nconst isRefPending = (ref?: RefObject<HTMLElement | null>) => {\n    if (!ref) return false\n    return !ref.current\n}\n\nexport function useScroll({\n    container,\n    target,\n    ...options\n}: UseScrollOptions = {}) {\n    const values = useConstant(createScrollMotionValues)\n    const scrollAnimation = useRef<VoidFunction | null>(null)\n    const needsStart = useRef(false)\n\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll(\n            (\n                _progress: number,\n                {\n                    x,\n                    y,\n                }: {\n                    x: { current: number; progress: number }\n                    y: { current: number; progress: number }\n                }\n            ) => {\n                values.scrollX.set(x.current)\n                values.scrollXProgress.set(x.progress)\n                values.scrollY.set(y.current)\n                values.scrollYProgress.set(y.progress)\n            },\n            {\n                ...options,\n                container: container?.current || undefined,\n                target: target?.current || undefined,\n            }\n        )\n\n        return () => {\n            scrollAnimation.current?.()\n        }\n    }, [container, target, JSON.stringify(options.offset)])\n\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false\n\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true\n            return\n        } else {\n            return start()\n        }\n    }, [start])\n\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(\n                !isRefPending(container),\n                \"Container ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            invariant(\n                !isRefPending(target),\n                \"Target ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            return start()\n        } else {\n            return\n        }\n    }, [start])\n\n    return values\n}\n"],"names":["observeTimeline","update","timeline","prevProgress","onFrame","currentTime","progress","value","frame","preUpdate","cancelFrame","resizeHandlers","WeakMap","observer","getSize","borderBoxAxis","svgAxis","htmlAxis","target","borderBoxSize","isSVGElement","getBBox","getWidth","getHeight","notifyTarget","_ref","_resizeHandlers$get","get","forEach","handler","width","height","notifyAll","entries","resizeElement","ResizeObserver","elements","resolveElements","element","_observer","elementHandlers","Set","set","add","observe","_observer2","delete","size","unobserve","windowCallbacks","windowResizeHandler","resizeWindow","callback","info","window","innerWidth","innerHeight","addEventListener","removeEventListener","undefined","keys","x","length","position","y","updateAxisInfo","axisName","time","axis","prev","current","prevTime","concat","scrollLength","offset","elapsed","velocity","velocityPerSecond","namedEdges","start","center","end","resolveEdge","edge","inset","arguments","delta","asNumber","parseFloat","endsWith","document","documentElement","clientWidth","clientHeight","defaultOffset","resolveOffset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","trim","includes","split","ScrollOffset","Enter","Exit","Any","All","point","resolveOffsets","container","options","lengthLabel","isHTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","svg","parent","parentNode","calcInset","targetSize","scrollWidth","scrollHeight","getTargetSize","containerSize","hasChanged","interpolate","numOffsets","i","interpolatorOffsets","clamp","createOnScrollHandler","onScroll","measure","targetOffset","node","updateScrollInfo","notify","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","scrollingElement","scrollInfo","_objectWithoutProperties","_excluded","noop","containerHandlers","containerHandler","has","measureAll","frameData","timestamp","listener","read","passive","b","a","currentHandlers","scrollListener","_resizeListeners$get","timelineCache","Map","getTimeline","_timelineCache$get","_options$target","_containerCache$get","_options$offset","source","containerCache","targetKey","targetCache","axisKey","join","supportsScrollTimeline","ScrollTimeline","cancel","scrollTimelineFallback","_objectSpread","scroll","optionsWithDefaults","isOnScrollWithInfo","attachToFunction","animation","attachTimeline","valueAnimation","pause","iterationDuration","attachToAnimation","createScrollMotionValues","scrollX","motionValue","scrollY","scrollXProgress","scrollYProgress","isRefPending","ref","useScroll","values","useConstant","scrollAnimation","useRef","needsStart","useCallback","_progress","_ref2","_scrollAnimation$curr","call","JSON","stringify"],"ignoreList":[],"sourceRoot":""}